[1mdiff --git a/hardware/ASyncTCP.cpp b/hardware/ASyncTCP.cpp[m
[1mindex f25635803..b5a7cf752 100644[m
[1m--- a/hardware/ASyncTCP.cpp[m
[1m+++ b/hardware/ASyncTCP.cpp[m
[36m@@ -3,6 +3,9 @@[m
 #include <boost/asio.hpp>[m
 #include <boost/bind.hpp>[m
 #include <boost/system/error_code.hpp>     // for error_code[m
[32m+[m[32m#include <boost/lexical_cast.hpp>[m
[32m+[m[32m#include "../main/Logger.h"[m
[32m+[m
 struct hostent;[m
 [m
 #ifndef WIN32[m
[36m@@ -15,6 +18,8 @@[m [mstruct hostent;[m
 [m
 ASyncTCP::ASyncTCP(const bool secure)[m
 	: mIsConnected(false), mIsClosing(false), mWriteInProgress(false),[m
[32m+[m	[32mm_tcpwork(std::make_shared<boost::asio::io_service::work>(mIos)),[m
[32m+[m	[32mm_Resolver(mIos),[m
 #ifdef WWW_ENABLE_SSL[m
 	mSecure(secure), m_Context(boost::asio::ssl::context::sslv23),[m
 #endif[m
[36m@@ -23,16 +28,9 @@[m [mASyncTCP::ASyncTCP(const bool secure)[m
 	mSslSocket(mIos, m_Context),[m
 #endif[m
 	mDoReconnect(true), mIsReconnecting(false),[m
[31m-	m_tcpwork(mIos),[m
 	mAllowCallbacks(true),[m
 	m_reconnect_delay(RECONNECT_TIME)[m
 {[m
[31m-	// Reset IO Service[m
[31m-	mIos.reset();[m
[31m-[m
[31m-	//Start IO Service worker thread[m
[31m-	m_tcpthread = std::make_shared<std::thread>(boost::bind(&boost::asio::io_service::run, &mIos));[m
[31m-[m
 #ifdef WWW_ENABLE_SSL[m
 	// we do not authenticate the server[m
 	m_Context.set_verify_mode(boost::asio::ssl::verify_none);[m
[36m@@ -46,7 +44,7 @@[m [mASyncTCP::~ASyncTCP(void)[m
 	// tell the IO service to stop[m
 	// we dont call mIos.stop() because our stop handlers wont be called anymore[m
 	// in stead, empty the work object and wait for all handlers to complete[m
[31m-	m_tcpwork = boost::none;[m
[32m+[m	[32mm_tcpwork.reset();[m
 	if (m_tcpthread)[m
 	{[m
 		m_tcpthread->join();[m
[36m@@ -61,61 +59,65 @@[m [mvoid ASyncTCP::SetReconnectDelay(int Delay)[m
 [m
 void ASyncTCP::connect(const std::string &ip, unsigned short port)[m
 {[m
[31m-	std::stringstream fip;[m
[32m+[m	[32mif (!m_tcpthread) {[m
[32m+[m		[32m//Start IO Service worker thread[m
[32m+[m		[32mm_tcpthread = std::make_shared<std::thread>(boost::bind(&boost::asio::io_service::run, &mIos));[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32m_log.Log(LOG_NORM, "Connecting to %s", ip.c_str());[m
[32m+[m	[32mm_Ip = ip;[m
[32m+[m	[32mm_Port = port;[m
[32m+[m	[32mstd::string port_str = boost::lexical_cast<std::string>(port);[m
 	// resolve hostname[m
[31m-	try[m
[31m-	{[m
[31m-		boost::asio::ip::tcp::resolver resolver(mIos);[m
[31m-		boost::asio::ip::tcp::resolver::query query(ip, "");[m
[31m-		for(auto i = resolver.resolve(query); i != boost::asio::ip::tcp::resolver::iterator(); ++i)[m
[31m-		{[m
[31m-			boost::asio::ip::tcp::endpoint end = *i;[m
[31m-			fip << end.address();[m
[31m-			break; // only retrieve the first address[m
[32m+[m	[32mboost::asio::ip::tcp::resolver::query query(ip, port_str);[m
[32m+[m	[32m_log.Log(LOG_NORM, "Starting async_resolve");[m
[32m+[m	[32mm_Resolver.async_resolve(query, boost::bind(&ASyncTCP::handle_resolve, this, boost::asio::placeholders::error, boost::asio::placeholders::iterator));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ASyncTCP::handle_resolve(const boost::system::error_code& err, boost::asio::ip::tcp::resolver::iterator endpoint_iterator)[m
[32m+[m[32m{[m
[32m+[m	[32m_log.Log(LOG_NORM, "In handle_resolve");[m
[32m+[m	[32mif (err) {[m
[32m+[m		[32m_log.Log(LOG_NORM, "handle_resolve error");[m
[32m+[m		[32mif (mAllowCallbacks) {[m
[32m+[m			[32mOnError(boost::system::error_code(err));[m
 		}[m
[31m-	}[m
[31m-	catch (const std::exception &e)[m
[31m-	{[m
[31m-		Q_UNUSED(e);[m
[31m-		if (!mAllowCallbacks)[m
[32m+[m		[32mif (!mDoReconnect)[m
[32m+[m		[32m{[m
[32m+[m			[32mif (mAllowCallbacks)[m
[32m+[m				[32mOnDisconnect();[m
 			return;[m
[31m-		OnError(boost::system::error_code(boost::asio::error::host_not_found));[m
[31m-	}[m
[31m-[m
[31m-	// connect socket[m
[31m-	try[m
[31m-	{[m
[31m-		boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::address::from_string(fip.str()), port);[m
[31m-		connect(endpoint);[m
[31m-	}[m
[31m-	catch(const std::exception &e)[m
[31m-	{[m
[31m-		if (mAllowCallbacks)[m
[31m-			OnError(e);[m
[32m+[m		[32m}[m
[32m+[m		[32mif (!mIsReconnecting)[m
[32m+[m		[32m{[m
[32m+[m			[32mStartReconnect();[m
[32m+[m		[32m}[m
[32m+[m		[32mreturn;[m
 	}[m
[32m+[m	[32mconnect(endpoint_iterator);[m
 }[m
 [m
[31m-void ASyncTCP::connect(boost::asio::ip::tcp::endpoint& endpoint)[m
[32m+[m[32mvoid ASyncTCP::connect(boost::asio::ip::tcp::resolver::iterator &endpoint_iterator)[m
 {[m
 	if(mIsConnected) return;[m
 	if(mIsClosing) return;[m
[32m+[m	[32m_log.Log(LOG_NORM, "Connecting to endpoint");[m
 [m
 	mAllowCallbacks = true;[m
 [m
[31m-	m_EndPoint = endpoint;[m
[32m+[m	[32mm_EndPoint = *endpoint_iterator++;[m
 [m
 #ifdef WWW_ENABLE_SSL[m
 	// try to connect, then call handle_connect[m
 	if (mSecure) {[m
[31m-		mSslSocket.lowest_layer().async_connect(endpoint,[m
[31m-			boost::bind(&ASyncTCP::handle_connect, this,[m
[31m-				boost::asio::placeholders::error));[m
[32m+[m		[32m_log.Log(LOG_NORM, "starting async_connect");[m
[32m+[m		[32mmSslSocket.lowest_layer().async_connect(m_EndPoint,[m
[32m+[m			[32mboost::bind(&ASyncTCP::handle_connect, this, boost::asio::placeholders::error, endpoint_iterator));[m
 	}[m
 	else[m
 #endif[m
 	{[m
[31m-		m_Socket.async_connect(endpoint,[m
[31m-			boost::bind(&ASyncTCP::handle_connect, this, boost::asio::placeholders::error));[m
[32m+[m		[32mm_Socket.async_connect(m_EndPoint, boost::bind(&ASyncTCP::handle_connect, this, boost::asio::placeholders::error, endpoint_iterator));[m
 	}[m
 }[m
 [m
[36m@@ -148,6 +150,15 @@[m [mvoid ASyncTCP::StartReconnect()[m
 {[m
 	if (m_reconnect_delay != 0)[m
 	{[m
[32m+[m[32m#ifdef WWW_ENABLE_SSL[m
[32m+[m		[32mif (mSecure) {[m
[32m+[m			[32mmSslSocket.lowest_layer().close();[m
[32m+[m		[32m}[m
[32m+[m		[32melse[m
[32m+[m[32m#endif[m
[32m+[m		[32m{[m
[32m+[m			[32mm_Socket.close();[m
[32m+[m		[32m}[m
 		mIsReconnecting = true;[m
 		// schedule a timer to reconnect after xx seconds[m
 		mReconnectTimer.expires_from_now(boost::posix_time::seconds(m_reconnect_delay));[m
[36m@@ -207,10 +218,12 @@[m [mvoid ASyncTCP::write(const std::string &msg)[m
 [m
 // callbacks[m
 [m
[31m-void ASyncTCP::handle_connect(const boost::system::error_code& error)[m
[32m+[m[32mvoid ASyncTCP::handle_connect(const boost::system::error_code& error, boost::asio::ip::tcp::resolver::iterator &endpoint_iterator)[m
 {[m
[32m+[m	[32m_log.Log(LOG_NORM, "in handle_connect");[m
 	if(mIsClosing) return;[m
 [m
[32m+[m	[32m_log.Log(LOG_NORM, "mIsClosing == false");[m
 	if (!error) {[m
 #ifdef WWW_ENABLE_SSL[m
 		if (mSecure) {[m
[36m@@ -241,6 +254,12 @@[m [mvoid ASyncTCP::handle_connect(const boost::system::error_code& error)[m
 [m
 	}[m
 	else {[m
[32m+[m		[32mif (endpoint_iterator != boost::asio::ip::tcp::resolver::iterator()) {[m
[32m+[m			[32m// The connection failed. Try the next endpoint in the list.[m
[32m+[m			[32mconnect(endpoint_iterator);[m
[32m+[m			[32mreturn;[m
[32m+[m		[32m}[m
[32m+[m		[32m_log.Log(LOG_NORM, "Error occurred");[m
 		// there was an error :([m
 		mIsConnected = false;[m
 [m
[36m@@ -263,6 +282,23 @@[m [mvoid ASyncTCP::handle_connect(const boost::system::error_code& error)[m
 #ifdef WWW_ENABLE_SSL[m
 void ASyncTCP::handle_handshake(const boost::system::error_code& error)[m
 {[m
[32m+[m	[32m_log.Log(LOG_NORM, "In handle_handshake");[m
[32m+[m	[32mif (error) {[m
[32m+[m		[32mif (mAllowCallbacks) {[m
[32m+[m			[32mOnError(boost::system::error_code(error));[m
[32m+[m		[32m}[m
[32m+[m		[32mif (!mDoReconnect)[m
[32m+[m		[32m{[m
[32m+[m			[32mif (mAllowCallbacks)[m
[32m+[m				[32mOnDisconnect();[m
[32m+[m			[32mreturn;[m
[32m+[m		[32m}[m
[32m+[m		[32mif (!mIsReconnecting)[m
[32m+[m		[32m{[m
[32m+[m			[32mStartReconnect();[m
[32m+[m		[32m}[m
[32m+[m		[32mreturn;[m
[32m+[m	[32m}[m
 	// we are connected![m
 	mIsConnected = true;[m
 [m
[36m@@ -382,17 +418,11 @@[m [mvoid ASyncTCP::do_reconnect(const boost::system::error_code& err)[m
 	}[m
 	mReconnectTimer.cancel();[m
 	// try to reconnect, then call handle_connect[m
[31m-#ifdef WWW_ENABLE_SSL[m
[31m-	if (mSecure) {[m
[31m-		mSslSocket.lowest_layer().async_connect(m_EndPoint,[m
[31m-			boost::bind(&ASyncTCP::handle_connect, this, boost::asio::placeholders::error));[m
[31m-	}[m
[31m-	else[m
[31m-#endif[m
[31m-	{[m
[31m-		m_Socket.async_connect(m_EndPoint,[m
[31m-			boost::bind(&ASyncTCP::handle_connect, this, boost::asio::placeholders::error));[m
[31m-	}[m
[32m+[m	[32mstd::string port_str = boost::lexical_cast<std::string>(m_Port);[m
[32m+[m	[32m// resolve hostname[m
[32m+[m	[32mboost::asio::ip::tcp::resolver::query query(m_Ip, port_str);[m
[32m+[m	[32m_log.Log(LOG_NORM, "Starting async_resolve");[m
[32m+[m	[32mm_Resolver.async_resolve(query, boost::bind(&ASyncTCP::handle_resolve, this, boost::asio::placeholders::error, boost::asio::placeholders::iterator));[m
 	mIsReconnecting = false;[m
 }[m
 [m
